#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TideApp - 应用程序主类

参考 Go 版本 sea 的 app 模块实现
提供应用程序生命周期管理、命令行支持、插件加载等功能
"""

import asyncio
import logging
import signal
import sys
from contextlib import asynccontextmanager
from typing import Any, Callable, Dict, List, Optional, Type, Union

import click

from tide.app.command import Command, CommandContext
from tide.app.hooks import HookManager, HookType
from tide.app.plugin import Plugin, PluginManager
from tide.config.config import TideConfig
from tide.provider.provider import Provider, get_provider

logger = logging.getLogger(__name__)


class TideApp:
    """
    Tide 应用程序主类

    提供：
    - 应用程序生命周期管理
    - 命令行支持 (基于 click)
    - 插件加载机制
    - 钩子函数 (PostStart, PreShutdown)
    - 优雅关闭

    使用示例：
        app = TideApp(name="my-service")

        @app.command()
        def serve(config: str = "conf/config.yaml"):
            app.run_with_config(config)

        if __name__ == "__main__":
            app.cli()
    """

    def __init__(
        self,
        name: str,
        version: str = "0.1.0",
        description: str = "",
    ):
        """
        初始化应用程序

        Args:
            name: 应用名称
            version: 版本号
            description: 应用描述
        """
        self.name = name
        self.version = version
        self.description = description

        # 组件
        self._config: Optional[TideConfig] = None
        self._provider: Provider = get_provider()
        self._plugin_manager = PluginManager()
        self._hook_manager = HookManager()

        # 命令
        self._commands: Dict[str, Command] = {}
        self._cli_group: Optional[click.Group] = None

        # 状态
        self._running = False
        self._shutdown_event: Optional[asyncio.Event] = None

        # 初始化 CLI
        self._init_cli()

    def _init_cli(self) -> None:
        """初始化 CLI"""

        @click.group(invoke_without_command=True)
        @click.version_option(version=self.version, prog_name=self.name)
        @click.pass_context
        def cli(ctx: click.Context) -> None:
            """Tide Application CLI"""
            ctx.ensure_object(dict)
            ctx.obj["app"] = self
            if ctx.invoked_subcommand is None:
                click.echo(ctx.get_help())

        self._cli_group = cli

        # 添加默认命令
        self._add_default_commands()

    def _add_default_commands(self) -> None:
        """添加默认命令"""

        @self._cli_group.command()
        @click.option(
            "--config", "-c", default="conf/config.yaml", help="配置文件路径"
        )
        @click.pass_context
        def serve(ctx: click.Context, config: str) -> None:
            """启动服务"""
            app: TideApp = ctx.obj["app"]
            app.run_with_config(config)

        @self._cli_group.command()
        @click.pass_context
        def info(ctx: click.Context) -> None:
            """显示应用信息"""
            app: TideApp = ctx.obj["app"]
            click.echo(f"Name: {app.name}")
            click.echo(f"Version: {app.version}")
            click.echo(f"Description: {app.description}")
            click.echo(f"Plugins: {list(app._plugin_manager._plugins.keys())}")

    def command(
        self,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> Callable:
        """
        命令装饰器

        Args:
            name: 命令名称
            **kwargs: 传递给 click.command 的参数

        Returns:
            装饰器函数
        """

        def decorator(func: Callable) -> Callable:
            cmd_name = name or func.__name__
            cmd = self._cli_group.command(name=cmd_name, **kwargs)(func)
            self._commands[cmd_name] = Command(
                name=cmd_name,
                func=func,
                description=func.__doc__ or "",
            )
            return cmd

        return decorator

    def register_plugin(self, plugin: Plugin) -> "TideApp":
        """
        注册插件

        Args:
            plugin: 插件实例

        Returns:
            self，支持链式调用
        """
        self._plugin_manager.register(plugin)
        return self

    def register_post_start_hook(
        self,
        name: str,
        func: Callable,
        priority: int = 0,
    ) -> "TideApp":
        """
        注册启动后钩子

        Args:
            name: 钩子名称
            func: 钩子函数
            priority: 优先级（越大越先执行）

        Returns:
            self
        """
        self._hook_manager.register(HookType.POST_START, name, func, priority)
        return self

    def register_pre_shutdown_hook(
        self,
        name: str,
        func: Callable,
        priority: int = 0,
    ) -> "TideApp":
        """
        注册关闭前钩子

        Args:
            name: 钩子名称
            func: 钩子函数
            priority: 优先级

        Returns:
            self
        """
        self._hook_manager.register(HookType.PRE_SHUTDOWN, name, func, priority)
        return self

    def run_with_config(self, config_path: str) -> None:
        """
        使用配置文件启动应用

        Args:
            config_path: 配置文件路径
        """
        from tide.config.loader import load_config_from_file

        config = load_config_from_file(config_path)
        self.run(config)

    def run(self, config: TideConfig) -> None:
        """
        启动应用

        Args:
            config: 应用配置
        """
        self._config = config
        self._provider.set_config(config)

        # 运行异步主循环
        try:
            asyncio.run(self._run_async())
        except KeyboardInterrupt:
            logger.info("Received keyboard interrupt")
        except Exception as e:
            logger.error(f"Application error: {e}", exc_info=True)
            sys.exit(1)

    async def _run_async(self) -> None:
        """异步运行主循环"""
        self._running = True
        self._shutdown_event = asyncio.Event()

        # 设置信号处理
        loop = asyncio.get_event_loop()
        for sig in (signal.SIGINT, signal.SIGTERM):
            loop.add_signal_handler(
                sig,
                lambda s=sig: asyncio.create_task(self._handle_signal(s)),
            )

        try:
            # 安装插件
            logger.info(f"Starting {self.name} v{self.version}")
            await self._install_plugins()

            # 执行启动后钩子
            await self._hook_manager.run_hooks(HookType.POST_START)

            # 等待关闭信号
            logger.info(f"{self.name} is running...")
            await self._shutdown_event.wait()

        finally:
            # 执行关闭前钩子
            logger.info("Shutting down...")
            await self._hook_manager.run_hooks(HookType.PRE_SHUTDOWN)

            # 卸载插件
            await self._uninstall_plugins()

            self._running = False
            logger.info(f"{self.name} stopped")

    async def _handle_signal(self, sig: signal.Signals) -> None:
        """处理系统信号"""
        logger.info(f"Received signal {sig.name}")
        if self._shutdown_event:
            self._shutdown_event.set()

    async def _install_plugins(self) -> None:
        """安装所有插件"""
        ctx = CommandContext(
            app=self,
            config=self._config,
            provider=self._provider,
        )
        await self._plugin_manager.install_all(ctx)

    async def _uninstall_plugins(self) -> None:
        """卸载所有插件"""
        ctx = CommandContext(
            app=self,
            config=self._config,
            provider=self._provider,
        )
        await self._plugin_manager.uninstall_all(ctx)

    def cli(self) -> None:
        """运行 CLI"""
        self._cli_group()

    @property
    def config(self) -> Optional[TideConfig]:
        """获取配置"""
        return self._config

    @property
    def provider(self) -> Provider:
        """获取 Provider"""
        return self._provider

    @property
    def is_running(self) -> bool:
        """是否正在运行"""
        return self._running
